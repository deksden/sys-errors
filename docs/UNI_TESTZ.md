# UNI_RESTZ :: Юнит тестирование системы (UNI_TESTZ.md, v0.1.6)

* В системе организовано юнит-тестирование
* Тест-раннер `vitest`, конфигурация в файле `vitest.config.js`
* тесты используют Dependency Injection, описанный в `DOC_DI.md`
* мы не мокаем логгер, используем отладочный вывод в тестах, логгер документирован в `DOC_SYS_LOGGER`
* тест кейсы разбиты на файлы, которые тестируют каждый файл оригинального кода
* если для нескольких тестов внутри подсистемы появляются общие фрагменты кода, которые целесообразно использовать в нескольких тестах, мы выделяем такой код в файл `test-utils.js` и используем в тестах
* тесты понимают паттерны цепочки ошибок и ошибки операции из `DOC_SYS_ERRORS`, обращают внимание на документацию функций в jsDoc
* имена файлов, версии, прочие моменты также описаны в RULEZZ, `RULEZZ.md`
* мы тестируем все функции, как внутренние, так и внешние

## Файлы тестов

* тесты создаются для каждой тестируемой функции в оригинальном файле кода
* размер файла тестов стараемся держать не более 250 строк кода (включая комментарии / jsDoc)
* если файл тестов превышают лимит, разбиваем тесты на несколько файлов, каждый файл именуется в соответствии с тестами в нем (это будет имя группы тестов)
* если файл тестов небольшой, и он один, то мы НЕ ИСПОЛЬЗУЕМ имя группы тестов в именовании файлов тестов
* имена файлов тестов составляются так: имя_оригинального_файла_кода.имя_функции.имя_группа_тестов.test.js
* обязательно используй имя оригинального файла кода и имя функции в имени тестового файла
* расположение файлов тестов (папка для файлов тестов):
  * все файлы тестов располагаются внутри папки "test/"
  * структура папок внутри "test/" повторяет структуру папок в "src/"; 
  * модули тестов расположены в папках аналогично основным модулям
  * если у оригинального модуля кода файлов тестов (из за наличия нескольких функций), мы для каждого оригинального файла кода в тестах делаем папку, совпадающую с его именем по такому принципу: например, у нас оригинальный файл кода `src/some-subsystem/big-file.js`, тогда файлы тестов разместим в папке `test/some-subsystem/big-file-js/`
  * обрати внимание - при создании папки для тестов оригинального файла кода мы добавляем суффикс "-js" к имени
* примеры имен файлов и папки: 
  * для оригинального файла `src/subsystem/some-file.js` с функцией `myFunction` будет создан файл с тестом `test/subsystem/some-file.my-function.test.js`
  * для большого файла `src/subsustem/big-file.js` с функцией `myComplexFunction` будут созданы тестовые файлы `test/subsystem/big-file-js/big-file.my-complex-function.basic.test.js` и `test/subsystem/big-file-js/big-file.my-complex-function.advanced-tests.test.js` (две группы тестов - "basic" и "advanced-tests")
  * обрати внимание - в имени файла мы записываем имя функции полностью, но маленькими буквами через дефиз - чтобы соответствовать правилам именования файлов в RULEZZ
  * неправильно, если папка без суффикса "-js", это ошибка; то есть путь `test/subsystem/big-file/big-file.my-complex-function.basic.test.js` неправильный и не соответствует требованиям, нужно папку с суффиксом, вот как правильно: `test/subsystem/big-file-js/big-file.my-complex-function.basic.test.js`

## Именование тест-кейсов: 

* имена тест кейсов строим так:
  * самый верхний уровень - это имя оригинального файла кода в круглых скобках и имя функции через точку, с описанием файла на русском языке, например `(big-file.myFunction) - тесты функции`
  * далее идет уровень тест кейсов, которые тоже могут быть логически сгруппированы, используй дополнительные уровни группировки describe при необходимости 
  * имена тестовых кейсов на русском языке
  * понятные имена тест кейсов отражают суть проверки
  * группируйте связанные тесты 
  * Используйте говорящие названия

## Построение тестов:

* тестируем ожидаемое поведение функции
* тестируем важные особенности реализации функции
* тестируем как позитивные, так и негативные сценарии
* детали реализации не проверяем, фокусируемся на тестировании важного и существенного
* обеспечиваем тестирование входных параметров:
  * валидные значения в допустимых диапазонах
  * граничные значения
  * некорректные типы данных иди данные с некорректной структурой
  * отсутствующие обязательные параметры
  * неожиданные значения (null, undefined, пустое значение)
* тестируем возвращаемые значения:
  * корректность и соответствие заявленной структуре
  * обработка специальных случаев (пустой результат, ошибки)
* тестирование ошибок / исключений:
  * соответствие паттерну SYS-ERRORS цепочка ошибок, ошибка операции
  * документированные исключения и их коды ошибок, 
  * детали реализации не тестируем (например, точный текст ошибок или детали структуры контекста), если такие детали отдельно не специфицированы документацией, 
  * отдельно специфицированные в документации детали тестируем
* код теста должен быть построен так:
  - логируем начало теста 
  - явно в тесте подготавливаем тестовое окружение, 
  - готовим тестовые данные,
  - логируем тестовые данные
  - делаем вызов тестируемой функции, получая результат
  - логируем результат
  - проводим необходимые проверки
  - логируем завершение теста
* мы обеспечиваем изоляцию тестов - каждый тест независим от других
* в начале файлов тестов вставляем стандартный (по RULEZZ) блок с jsDoc комментариями с тэгами `@file` с путём к файлу и его именем, с `@description` кратким описанием файла, `@version` с текущей версией тестового файла "x.y.z", 
* далее файлы тестов содержат дополнения к стандартному jsDoc с дополнительными тегами:
  - `@tested-file`: оригинальный файл кода
  - `@tested-file-version`: версия оригинального файла кода
  - `@test-doc`: имя файла документации модульных тестов, в соответствии с которым сделан этот тест
* используем принцип **устойчивости тестов**:
  - тестируем важные особенности
  - не тестируем детали реализации если они не специфицированы в документации (формат вывода, точный текст сообщений, точная структура объектов если она не существенна)
  - стараемся сделать тесты устойчивыми к потенциальному изменению структуры данных или исключений


## Моки и стабы:

* без абсолютной необходимости, НЕ МОКАЕМ логгер, чтобы сохранить отладочный вывод в тестах
* моки и стабы должны корректно имитировать оригинальный код, при этом обеспечивая выполнение тестового сценария
* используем DI 
* внимательно проверяем параметры моков, чтобы они совпадали с параметрами оригинальных функций
* внимательно смотрим на формат возвращаемых моком результатов, чтобы он соответсвовал оригинальной функции
* НЕ МОКАЕМ детерминированные функции, если у них нет сайд-эффектов
* следим за соответствием выбрасываемых моком исключений, чтобы это соответствовало логике оригинального кода
* сопоставляем поведение мока с документацией jsDoc оригинальной функции
* не мокаем функцию, если нет целесообразности
* в начале теста сохраняем все зависимости, которые мокаем
* после завершения тестов восстанавливаем зависимости в первоначальное состояние
* используем логгер внутри моков, при этом ясно указываем в сообщениях что это мок;


## Использование логгера SYS_LOGGER:

* следуем рекомендациям из SYS_LOGGER (документированы в `DOC_SYS-LOGGER`)
* для тестов заводим соответствующий namespace
* моки также должны содержать логгер
* ВАЖНО! в сообщения логгера из мока явно указывай что это мок функции, а не сама функция
* используйте уровни логирования по назначению:
  * trace - для отслеживания хода выполнения теста (вход/выход из теста, основные шаги)
  * debug - для отладочных данных (входные данные, промежуточные значения, результаты)
  * info и выше - для значимых событий теста
  * error при ошибках


## Рекомендации:

* Понятные имена тестов:
  - Документируйте комментариями тестовые данные, которые готовятся в тесте
  - Используйте логирование, чтобы зафиксировать передаваемые тестовые данные 
  - Описывайте ожидаемое поведение
  - Описывайте ожидаемые данные, которые проверяете
  - Используйте логирование, чтобы видеть данные, которые вернулись для проверки
  - Указывайте контекст выполнения

* Организация кода теста:
  - Разделяйте подготовку, действие и проверку
  - Используйте осмысленные имена переменных
  - Проверяйте важные особенности поведения, ожидаемое поведение
  - Комментируйте сложную логику
  - Обеспечивайте устойчивость тестов

* Работа с асинхронным кодом:
  - Всегда используйте async/await
  - Проверяйте reject/resolve промисов
  - Учитывайте порядок асинхронных операций
  - Правильно обрабатывайте ошибки

* Моки и стабы:
   - Мокайте только необходимые зависимости
   - Не мокаем логгер без крайней необходимости
   - не мокаем детерминированные функции без сайд-эффектов
   - мокаем только те функции, которые необходимо
   - Воспроизводите реальное поведение
   - Проверяйте корректность вызовов
   - Восстанавливайте оригинальные объекты по завершении теста
